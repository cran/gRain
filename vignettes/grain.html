<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Graphical Independence Networks</title>
<style type="text/css">
/**
 * Prism.s theme ported from highlight.js's xcode style
 */
pre code {
  padding: 1em;
}
.token.comment {
  color: #007400;
}
.token.punctuation {
  color: #999;
}
.token.tag,
.token.selector {
  color: #aa0d91;
}
.token.boolean,
.token.number,
.token.constant,
.token.symbol {
  color: #1c00cf;
}
.token.property,
.token.attr-name,
.token.string,
.token.char,
.token.builtin {
  color: #c41a16;
}
.token.inserted {
  background-color: #ccffd8;
}
.token.deleted {
  background-color: #ffebe9;
}
.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
  color: #9a6e3a;
}
.token.atrule,
.token.attr-value,
.token.keyword {
  color: #836c28;
}
.token.function,
.token.class-name {
  color: #DD4A68;
}
.token.regex,
.token.important,
.token.variable {
  color: #5c2699;
}
.token.important,
.token.bold {
  font-weight: bold;
}
.token.italic {
  font-style: italic;
}
</style>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
  box-sizing: border-box;
}
body, .footnotes, code { font-size: .9em; }
li li { font-size: .95em; }
*, *:before, *:after {
  box-sizing: inherit;
}
pre, img { max-width: 100%; }
pre, pre:hover {
  white-space: pre-wrap;
  word-break: break-all;
}
pre code {
  display: block;
  overflow-x: auto;
}
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre) > code, code[class] { background-color: #F8F8F8; }
code.language-undefined, pre > code:not([class]) {
  background-color: inherit;
  border: 1px solid #eee;
}
table {
  margin: auto;
  border-top: 1px solid #666;
}
table thead th { border-bottom: 1px solid #ddd; }
th, td { padding: 5px; }
thead, tfoot, tr:nth-child(even) { background: #eee; }
blockquote {
  color: #666;
  margin: 0;
  padding-left: 1em;
  border-left: 0.5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC .numbered li { list-style: none; }
#TOC .numbered { padding-left: 0; }
#TOC .numbered ul { padding-left: 1em; }
table, .body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.footnote-ref a::before { content: "["; }
.footnote-ref a::after { content: "]"; }
section.footnotes::before {
  content: "";
  display: block;
  max-width: 20em;
}

@media print {
  body {
    font-size: 12pt;
    max-width: 100%;
  }
  tr, img { page-break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  pre { white-space: pre; }
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
</head>
<body>
<div class="frontmatter">
<div class="title"><h1>Graphical Independence Networks</h1></div>
<div class="author"><h2>Søren Højsgaard</h2></div>
<div class="date"><h3></h3></div>
</div>
<div class="body">
<p>\tableofcontents</p>
<h1 id="bayesian-networks">Bayesian networks</h1>
<h2 id="introduction">Introduction</h2>
<p>The gRain package implements Bayesian Networks (hereafter often
abbreviated BNs). The name gRain is an acronym for [gra]phical
[i]ndependence [n]etworks. The main reference for gRain  is
@hoj:12, see also <code>citation(&quot;gRain&quot;)</code>.</p>
<p>Moreover, @hoj:edw:lau:12 gives a broad treatment of graphical
models (including Bayesian networks) More information about the
package, other graphical modelling packages and development versions
is available from</p>
<p>\begin{quote} (http://people.math.aau.dk/~sorenh/software/gR) \end{quote}</p>
<!-- ## Two worked examples {#sec:two-worked-examples} -->
<!-- ### Wet grass {#sec:wet-grass} -->
<!-- The `wet grass` example is motivated by the following narrative (taken from  -->
<!-- (https://en.wikipedia.org/wiki/Bayesian_network)): -->
<!--   *"Two events can cause grass to be wet: an active sprinkler or -->
<!--   rain. Rain has a direct effect on the use of the sprinkler (namely -->
<!--   that when it rains, the sprinkler usually is not active).*" -->
<!-- ```{r echo=F, results='hide'} -->
<!-- yn <- c("yes","no") -->
<!-- p.R    <- cpt(~R, values=c(2, 8), levels=yn) -->
<!-- p.S_R  <- cpt(~S:R, values=c(1, 99, 4, 6), levels=yn) -->
<!-- p.G_SR <- cpt(~G:S:R, values=c(99, 1, 8, 2, 9, 1, 0, 1), levels=yn) -->
<!-- grass_bn <- compile_cpt(p.R, p.S_R, p.G_SR)  %>% grain -->
<!-- ```  -->
<!-- ```{r chest-grass, fig.height=5, echo=F, fig.cap="Wet graph example; taken from Wikipedia."} -->
<!-- par(mar=c(0,0,0,0)) -->
<!-- plot(grass_bn$dag) -->
<!-- ``` -->
<h3 id="example-chest-clinic" #sec:chest-clinic>Example: Chest clinic</h3>
<p>This section reviews the chest clinic example of @lau/spieg:88
(illustrated in Figure @ref(fig:chest-LS)) and shows one way of
specifying the model in gRain.  @lau/spieg:88 motivate the
chest clinic example with the following narrative:</p>
<p><em>``Shortness–of–breath (dyspnoea) may be due to tuberculosis, lung
cancer or bronchitis, or none of them, or more than one of them. A
recent visit to Asia increases the chances of tuberculosis, while
smoking is known to be a risk factor for both lung cancer and
bronchitis. The results of a single chest X–ray do not discriminate
between lung cancer and tuberculosis, as neither does the presence or
absence of dyspnoea.’’</em></p>
<pre><code class="language-r">chest_dag &lt;- dag(list(&quot;asia&quot;, c(&quot;tub&quot;, &quot;asia&quot;), &quot;smoke&quot;, c(&quot;lung&quot;, &quot;smoke&quot;), c(&quot;bronc&quot;, 
&quot;smoke&quot;), c(&quot;either&quot;, &quot;tub&quot;, &quot;lung&quot;), c(&quot;xray&quot;, &quot;either&quot;), c(&quot;dysp&quot;, 
&quot;bronc&quot;, &quot;either&quot;)))
</code></pre>
<p><img src="data:image/png;base64,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" alt="Chest clinic example from Lauritzen and Spiegelhalter (1988)." /></p>
<h2 id="building-a-bayesian-network">Building a Bayesian network</h2>
<p>The description above involves the following binary variables:
\(a=\mbox{asia}\),
\(s=\mbox{smoker}\),
\(t=\mbox{tuberculosis}\),
\(l=\mbox{lung cancer}\),
\(b=\mbox{bronchitis}\),
\(e=\mbox{either tuberculosis or lung cancer}\),
\(d=\mbox{dyspnoea}\) and
\(x=\mbox{xray}\).</p>
<p>Each variable is binary and can take the values “yes” and “no”: Note
that \(e\) is a logical variable which is true (yes) if either \(t\) or
\(l\) are true (yes) and false (no) otherwise.  The connection between
the variables is displayed by the DAG (directed acyclic graph) in
Figure~@ref(fig:chest-LS).</p>
<p>A joint probability density factorizing according to a DAG with nodes
\(V\) can be constructed as follows: Each node \(v\in V\) has a set
\(pa(v)\) of parents and each node \(v\in V\) has a finite set of
states. A joint distribution over the variables \(V\) can be given as a
product of conditional distributions</p>
<p>\begin{align} (\#eq:dagfact1) p(V) = \prod_{v\in V} p(v|pa(v)) \end{align}</p>
<p>where \(p(v|pa(v))\) is a function defined on \((v,pa(v))\). This function
satisfies that
$$
\sum_{v^<em>} p(v=v^</em>|pa(v))=1,
$$</p>
<p>i.e.\ that for each configuration of the parents \(pa(v)\), the sum over
the levels of \(v\) equals one. Hence \(p(v|pa(v))\) becomes the
conditional distribution of \(v\) given \(pa(v)\).  In practice
\(p(v|pa(v))\) is specified as a table called a conditional probability
table or a CPT for short.  Thus, a Bayesian network can be regarded as
a complex stochastic model built up by putting together simple
components (conditional probability distributions).  A joint
probability density for all eight variables in
Figure~@ref(fig:chest-LS) can be constructed as</p>
<p>\begin{align} (\#eq:chestfact1) p(V) = p(a)p(s)p(t|a)p(l|s)p(b|s)p(e|t,l) p(d|e, b)p(x|e). \end{align}</p>
<h2 id="queries-to-networks">Queries to networks</h2>
<p>Suppose we are given the evidence (sometimes also called “finding”)
that a set of variables \(E\subset V\) have a specific value \(e^*\).
With this evidence, we are often interested in the conditional
distribution \(p(v|E=e^*)\) for some of the variables $v \in V \setminus
E$ or in \(p(U|E=e^*)\) for a set \(U\subset V \setminus E\). Interest
might also be in calculating the probability of a specific event,
e.g.\ the probability of seeing a specific evidence, i.e.\ \(p(E=e^*)\).
Other types of evidence (called soft evidence, virtual evidence or
likelihood evidence) are discussed in Section @ref(sec:hard-soft).</p>
<p>For example that a person has recently visited Asia and suffers from
dyspnoea, i.e.\ \(a=\mbox{yes}\) and \(d=\mbox{yes}\).  In the chest
clinic example, interest might be in \(p(l|e^*)\), \(p(t|e^*)\) and
\(p(b|e^*)\), or possibly in the joint (conditional) distribution
\(p(l,t,b|e^*)\).</p>
<h2 id="a-one-minute-version-of-grain">A one–minute version of gRain</h2>
<h3 id="specifying-a-bayesian-network">Specifying a Bayesian network</h3>
<p>A simple way of  specifying the model for the chest clinic
example is as follows.</p>
<p>Specify conditional probability tables (with values as given in
@lau/spieg:88) (there are other ways of specifying conditional
probability tables, see the package documentation):</p>
<pre><code class="language-r">yn &lt;- c(&quot;yes&quot;,&quot;no&quot;)
a    &lt;- cpt(~asia, values=c(1, 99),levels=yn)
t.a  &lt;- cpt(~tub|asia, values=c(5, 95, 1, 99),levels=yn)
s    &lt;- cpt(~smoke, values=c(5, 5), levels=yn)
l.s  &lt;- cpt(~lung|smoke, values=c(1, 9, 1, 99), levels=yn)
b.s  &lt;- cpt(~bronc|smoke, values=c(6, 4, 3, 7), levels=yn)
e.lt &lt;- cpt(~either|lung:tub,values=c(1, 0, 1, 0, 1, 0, 0, 1),levels=yn)
x.e  &lt;- cpt(~xray|either, values=c(98, 2, 5, 95), levels=yn)
d.be &lt;- cpt(~dysp|bronc:either, values=c(9, 1, 7, 3, 8, 2, 1, 9), levels=yn)
</code></pre>
<p>Compile list of conditional probability tables.</p>
<pre><code class="language-r">chest_cpt &lt;- compile_cpt(a, t.a, s, l.s, b.s, e.lt, x.e, d.be)
chest_cpt
</code></pre>
<pre><code>##  P( asia )
##  P( tub | asia )
##  P( smoke )
##  P( lung | smoke )
##  P( bronc | smoke )
##  P( either | lung tub )
##  P( xray | either )
##  P( dysp | bronc either )
</code></pre>
<p>The components are arrays, but coercion into dataframes sometimes
makes it easier to digest the components.</p>
<pre><code class="language-r">chest_cpt$tub
</code></pre>
<pre><code>##      asia
## tub    yes   no
##   yes 0.05 0.01
##   no  0.95 0.99
</code></pre>
<pre><code class="language-r">chest_cpt$tub  |&gt; as.data.frame.table()
</code></pre>
<pre><code>##   tub asia Freq
## 1 yes  yes 0.05
## 2  no  yes 0.95
## 3 yes   no 0.01
## 4  no   no 0.99
</code></pre>
<p>Create the network:</p>
<pre><code class="language-r">chest_bn &lt;- grain(chest_cpt)
chest_bn
</code></pre>
<pre><code>## Independence network: Compiled: TRUE Propagated: FALSE Evidence: FALSE
</code></pre>
<p>Default is that the network is compiled at creation time, but if one
chooses not to do so, compilation can be done with:</p>
<pre><code class="language-r">chest_bn &lt;- compile(chest_bn)
</code></pre>
<h3 id="setting-evidence-and-querying-a-network" #sec:querying-network>Setting evidence and querying a network</h3>
<p>In the chest clinic example, there are three disease variables, two
background variables and two symptoms. Following the narrative, we can
set evidence that a person has recently visited Asia and has dyspnoea:</p>
<pre><code class="language-r">disease &lt;- c(&quot;tub&quot;, &quot;lung&quot;, &quot;bronc&quot;)
asia_dysp &lt;- list(asia=&quot;yes&quot;, dysp=&quot;yes&quot;)
</code></pre>
<p>Initially, the network can be queried without evidence:</p>
<pre><code class="language-r">chest_bn |&gt; querygrain(nodes=disease, type=&quot;marginal&quot;)
</code></pre>
<pre><code>## $tub
## tub
##    yes     no 
## 0.0104 0.9896 
## 
## $lung
## lung
##   yes    no 
## 0.055 0.945 
## 
## $bronc
## bronc
##  yes   no 
## 0.45 0.55
</code></pre>
<pre><code class="language-r">chest_bn |&gt; querygrain(nodes=disease, type=&quot;marginal&quot;, simplify = TRUE)
</code></pre>
<pre><code>##          yes     no
## tub   0.0104 0.9896
## lung  0.0550 0.9450
## bronc 0.4500 0.5500
</code></pre>
<pre><code class="language-r">chest_bn |&gt; querygrain(nodes=disease, type=&quot;joint&quot;) 
</code></pre>
<pre><code>## , , bronc = yes
## 
##      lung
## tub         yes       no
##   yes 0.0003276 0.004352
##   no  0.0311724 0.414148
## 
## , , bronc = no
## 
##      lung
## tub         yes       no
##   yes 0.0002444 0.005476
##   no  0.0232556 0.521024
</code></pre>
<pre><code class="language-r">chest_bn |&gt; querygrain(nodes=disease, type=&quot;joint&quot;, simplify = TRUE)
</code></pre>
<pre><code>##   tub lung bronc      Freq
## 1 yes  yes   yes 0.0003276
## 2  no  yes   yes 0.0311724
## 3 yes   no   yes 0.0043524
## 4  no   no   yes 0.4141476
## 5 yes  yes    no 0.0002444
## 6  no  yes    no 0.0232556
## 7 yes   no    no 0.0054756
## 8  no   no    no 0.5210244
</code></pre>
<pre><code class="language-r">chest_bn |&gt; querygrain(nodes=disease, type=&quot;conditional&quot;)
</code></pre>
<pre><code>## , , bronc = yes
## 
##      lung
## tub      yes     no
##   yes 0.0104 0.0104
##   no  0.9896 0.9896
## 
## , , bronc = no
## 
##      lung
## tub      yes     no
##   yes 0.0104 0.0104
##   no  0.9896 0.9896
</code></pre>
<pre><code class="language-r">chest_bn |&gt; querygrain(nodes=disease, type=&quot;conditional&quot;, simplify = TRUE)
</code></pre>
<pre><code>##   tub lung bronc   Freq
## 1 yes  yes   yes 0.0104
## 2  no  yes   yes 0.9896
## 3 yes   no   yes 0.0104
## 4  no   no   yes 0.9896
## 5 yes  yes    no 0.0104
## 6  no  yes    no 0.9896
## 7 yes   no    no 0.0104
## 8  no   no    no 0.9896
</code></pre>
<p>Above we obtain the marginal, joint distributions and conditional
distribution for the disease variables. The output can in some cases
be simplified to dataframes. For the conditional distribution, we
obtain the conditional distribution of the first node given the rest
of the nodes.</p>
<h2 id="setting-evidence">Setting evidence</h2>
<p>Evidence can be entered in different ways:</p>
<pre><code class="language-r">asia_dysp &lt;- list(asia=&quot;yes&quot;, dysp=&quot;yes&quot;)

chest_ev &lt;- chest_bn |&gt;
    evidence_add(evidence=asia_dysp)
</code></pre>
<p>The evidence is a list and can conveniently be displayed as a dataframe:</p>
<pre><code class="language-r">chest_ev |&gt; evidence_get() 
</code></pre>
<pre><code>##   nodes is_hard hard_state evi_weight
## 1  asia    TRUE        yes       1, 0
## 2  dysp    TRUE        yes       1, 0
</code></pre>
<pre><code class="language-r">chest_ev |&gt; querygrain(nodes=disease, simplify = TRUE)
</code></pre>
<pre><code>##           yes     no
## tub   0.08775 0.9122
## lung  0.09953 0.9005
## bronc 0.81140 0.1886
</code></pre>
<pre><code class="language-r">chest_ev |&gt; evidence_prob()
</code></pre>
<pre><code>## [1] 0.004501
</code></pre>
<p>The network can be queried again, and we can also obtain the
probability of observing this evidence:</p>
<pre><code class="language-r">chest_ev |&gt; querygrain(nodes=disease, simplify=TRUE)
</code></pre>
<pre><code>##           yes     no
## tub   0.08775 0.9122
## lung  0.09953 0.9005
## bronc 0.81140 0.1886
</code></pre>
<pre><code class="language-r">chest_ev |&gt; evidence_prob()
</code></pre>
<pre><code>## [1] 0.004501
</code></pre>
<pre><code class="language-r">chest_bn |&gt; evidence_prob(evidence=list(asia=&quot;yes&quot;, dysp=&quot;yes&quot;))
</code></pre>
<pre><code>## [1] 0.004501
</code></pre>
<p>The probability of observing a specific evidence can be found by
setting the evidence as a vector of weights. This is useful in
connection with soft evidence (also called likelihood evidence), see
Section~@ref(sec:hard-soft).</p>
<h2 id="hints-and-shortcuts" #sec:small-shortcuts>Hints and shortcuts</h2>
<p>An alternative way of specifying a network is by first defining CPTs
and then entering values afterwards. Programmatically, this can be
done as:</p>
<pre><code class="language-r">yn &lt;- c(&quot;yes&quot;, &quot;no&quot;)

node_parents_list &lt;-
    list(&quot;asia&quot;, c(&quot;tub&quot;, &quot;asia&quot;), &quot;smoke&quot;, c(&quot;lung&quot;, &quot;smoke&quot;),
         c(&quot;bronc&quot;, &quot;smoke&quot;), c(&quot;either&quot;, &quot;tub&quot;, &quot;lung&quot;),
         c(&quot;xray&quot;, &quot;either&quot;), c(&quot;dysp&quot;, &quot;bronc&quot;, &quot;either&quot;))

chest_dummy_cpt2 &lt;- lapply(node_parents_list, function(f){
    cpt(f, levels=yn)
})
bn_temp &lt;- compile_cpt(chest_dummy_cpt2) |&gt; grain()
</code></pre>
<p>Above the network has ones in all potentials. Next update values in
(some of the) potentials:</p>
<pre><code class="language-r">cpt_values &lt;- list(asia=c(1, 99),
                   tub=c(5, 95, 1, 99),
                   smoke=c(5, 5),
                   lung=c(1, 9, 1, 99),            
                   bronc=c(6, 4, 3, 7),
                   either=c(1, 0, 1, 0, 1, 0, 0, 1),
                   xray=c(98, 2, 5, 95),
                   dysp=c(9, 1, 7, 3, 8, 2, 1, 9))
bn_real &lt;- replace_cpt(bn_temp, cpt_values)
</code></pre>
<pre><code class="language-r">bn_temp |&gt; querygrain(evi=asia_dysp, nodes=disease, simplify = TRUE)
</code></pre>
<pre><code>##       yes  no
## tub   0.5 0.5
## lung  0.5 0.5
## bronc 0.5 0.5
</code></pre>
<pre><code class="language-r">bn_real |&gt; querygrain(evi=asia_dysp, nodes=disease, simplify = TRUE)
</code></pre>
<pre><code>##           yes     no
## tub   0.08775 0.9122
## lung  0.09953 0.9005
## bronc 0.81140 0.1886
</code></pre>
<p>Consider querying a network where focus is on
marginal distributions (the default). If all variables have the same
levels (as the case is here), the output can be coerced to a
dataframe:</p>
<pre><code class="language-r">querygrain(chest_bn, nodes=disease, simplify = TRUE)
</code></pre>
<pre><code>##          yes     no
## tub   0.0104 0.9896
## lung  0.0550 0.9450
## bronc 0.4500 0.5500
</code></pre>
<p>In the more general case the output can be coerced to a list of dataframes</p>
<pre><code class="language-r">querygrain(chest_bn, nodes=disease, result=&quot;data.frame&quot;)
</code></pre>
<pre><code>## $tub
## tub
##    yes     no 
## 0.0104 0.9896 
## 
## $lung
## lung
##   yes    no 
## 0.055 0.945 
## 
## $bronc
## bronc
##  yes   no 
## 0.45 0.55
</code></pre>
<p>A typical use of gRain involves setting evidence and then
querying the network afterwards. This can all be done in one call of
<code>querygrain()</code> (notice that this does not alter the network object):</p>
<pre><code class="language-r">chest_bn |&gt; querygrain(evidence=asia_dysp,
                       nodes=disease, simplify = TRUE)
</code></pre>
<pre><code>##           yes     no
## tub   0.08775 0.9122
## lung  0.09953 0.9005
## bronc 0.81140 0.1886
</code></pre>
<p>Evidence can be also be given as a vector of weights.</p>
<pre><code class="language-r">chest_bn |&gt; querygrain(evidence=list(asia=c(1, 0), dysp=c(1, 0)),
                       nodes=disease, simplify = TRUE)
</code></pre>
<pre><code>##           yes     no
## tub   0.08775 0.9122
## lung  0.09953 0.9005
## bronc 0.81140 0.1886
</code></pre>
<p>The weights must be non-negative but need not sum to one. This is
important in connection with soft evidence (also called likelihood
evidence), see Section~@ref(sec:hard-soft). Above, the weights could
also have been set as c(.1, 0). The important part is that the
zero excludes certain states as being impossible.</p>
<p>Nodes on which evidence is given are not reported unless <code>exclude=FALSE</code></p>
<pre><code class="language-r">querygrain(chest_bn,
           evidence=list(asia=c(1, 0), dysp=c(1, 0)),
           nodes=c(&quot;lung&quot;, &quot;bronc&quot;, &quot;asia&quot;, &quot;dysp&quot;),
           exclude=FALSE, simplify = TRUE)
</code></pre>
<pre><code>##           yes     no
## asia  1.00000 0.0000
## lung  0.09953 0.9005
## bronc 0.81140 0.1886
## dysp  1.00000 0.0000
</code></pre>
<p>If <code>nodes</code>are not specified, queries for all nodes without evidence are reported.</p>
<pre><code class="language-r">querygrain(chest_bn,
           evidence=asia_dysp,
           simplify = TRUE)
</code></pre>
<pre><code>##            yes     no
## tub    0.08775 0.9122
## lung   0.09953 0.9005
## either 0.18230 0.8177
## bronc  0.81140 0.1886
## smoke  0.62592 0.3741
## xray   0.21954 0.7805
</code></pre>
<p>If <code>nodes</code> are not specified and <code>exclude=FALSE</code>, then queries for all nodes are reported.</p>
<pre><code class="language-r">querygrain(chest_bn,
           evidence=asia_dysp,
           exclude = FALSE, simplify = TRUE)
</code></pre>
<pre><code>##            yes     no
## asia   1.00000 0.0000
## tub    0.08775 0.9122
## lung   0.09953 0.9005
## either 0.18230 0.8177
## bronc  0.81140 0.1886
## smoke  0.62592 0.3741
## dysp   1.00000 0.0000
## xray   0.21954 0.7805
</code></pre>
<h2 id="conditioning-on-evidence-with-zero-probability" #sec:zero-probabilities>Conditioning on evidence with zero probability</h2>
<p>Consider setting the evidence</p>
<pre><code class="language-r">chest_bn3 &lt;- evidence_add(chest_bn, evidence=list(either=&quot;no&quot;, tub=&quot;yes&quot;))
</code></pre>
<p>Under the model, this specific evidence has zero probability:
<code>either</code> is true if <code>tub</code> is true or <code>lung</code> is true (or
both). Hence the specific evidence is impossible and therefore, all
conditional probabilities are (under the model) undefined:</p>
<pre><code class="language-r">evidence_prob(chest_bn3)
</code></pre>
<pre><code>## [1] 0
</code></pre>
<pre><code class="language-r">querygrain(chest_bn3, nodes=disease, type=&quot;joint&quot;)
</code></pre>
<pre><code>##      bronc
## lung  yes  no
##   yes NaN NaN
##   no  NaN NaN
</code></pre>
<h2 id="hard-and-soft-likelihood-evidence" #sec:hard-soft>Hard and soft (likelihood) evidence</h2>
<p>Below we describe  how to work with virtual evidence (also known
as soft evidence or likelihood evidence) in gRain. This is done via the function
evidence_add().</p>
<p>The clique potential representation in a Bayesian network gives
\begin{align} p(x) \propto \psi(x) = \prod_{C} \psi_C(x_C). \end{align}</p>
<p>Here we recall that the whole idea in computations with Bayesian
networks is to avoid calculation the product on the right hand
side above. Instead computations are based on propagation (multiplying,
dividing and summing clique potentials \(\psi_C\) in an appropriate
order, and such an appropriate order comes from a junction tree).
The normalizing constant, say \(c=\sum_x \psi(x)\), comes out of
propagation as a “by-product”.</p>
<p>Suppose a set of nodes \(E\) are known to have a specific value,
i.e. \(x_E=x^*_E\). This is called hard evidence. The probability of
the event \(x_E=x^*_E\) is
\begin{align} p(x_E=x^*_E)=E_p\{I(x_E=x^*_E)\} = \sum_x I(x_E=x^*_E) p(x) = \frac{1}{c} \sum_x I(x_E=x^*_E) \psi(x) \end{align}</p>
<p>The computations are based on modifying the clique potentials \(\psi_C\)
by giving value zero to states in \(\psi_C\) which are not consistent
with \(x_E=x^*_E\). This can be achieved with an indicator function, say
\(L_C(x_C)\) such that we obtain a set of new potentials $\tilde \psi_C(x)
= L_C(x_C) \psi_C(x_C)$. Propagation with these new potentials gives,
as a by product, \(\tilde c=\sum \tilde \psi(x)\) where
\(\tilde\psi(x)= \prod_C \tilde\psi_C(x_C)\). Consequently, we have
\(p(x_E=x^*_E)=\tilde c / c\).</p>
<p>In a more general setting we may have non–negative weights \(L(x)\) for
each value of \(x\). We may calculate
\begin{align} E_p\{L(X)\} = \sum_x L(x)p(x) \end{align}
If \(L(X)\) factorizes as \(L(X)= \prod_C L_C(X_C)\) then the computations are
carried out as outlined above, i.e.\ by the message passing scheme.</p>
<h3 id="hard-evidence" #sec:hard-evidence>Hard evidence </h3>
<p>Suppose we want to make a diagnosis about tuberculosis given the evidence that a person is a smoker.
We call such evidence hard evidence because the state of the variables are known with certainty.
The function setEvidence() can  be used for this purpose. The following forms are equivalent (the reason will be explained below):</p>
<pre><code class="language-r">chest_ev1 &lt;- chest_bn |&gt; evidence_add(list(smoke=&quot;yes&quot;))
chest_ev2 &lt;- chest_bn |&gt; evidence_add(list(smoke=c(1, 0)))
</code></pre>
<pre><code class="language-r">chest_bn |&gt; querygrain(nodes=disease, simplify = TRUE)
</code></pre>
<pre><code>##          yes     no
## tub   0.0104 0.9896
## lung  0.0550 0.9450
## bronc 0.4500 0.5500
</code></pre>
<pre><code class="language-r">chest_ev1 |&gt; querygrain(nodes=disease, simplify = TRUE)
</code></pre>
<pre><code>##          yes     no
## tub   0.0104 0.9896
## lung  0.1000 0.9000
## bronc 0.6000 0.4000
</code></pre>
<h3 id="soft-evidence-also-called-virtual-evidence-or-likelihood-evidence" #sec:virt-evid-likel>Soft evidence (also called virtual evidence or likelihood evidence)</h3>
<p>Suppose we are not certain if a patient is a smoker or not. We shall assume that for patients who are smokers, we would (correctly) guess so in 80% of the cases, whereas for patients who are not smokers we would (erroneously) guess that they are smokers in 10% of the cases.</p>
<p>In gRain this, situation can be handled in two different ways. One way is to introduce a new variable <code>smoke_guess</code> with <code>smoke</code> as its only parent and then we enter evidence for this node.</p>
<pre><code class="language-r">g.s &lt;- cpt(~ smoke_guess|smoke, levels=yn,
              values=c(.8, .2, .1, .9))
g.s
</code></pre>
<pre><code>##            smoke
## smoke_guess yes  no
##         yes 0.8 0.1
##         no  0.2 0.9
</code></pre>
<pre><code class="language-r">chest_ext &lt;- c(cpt_list, list(g.s)) |&gt; compile_cpt() |&gt; grain()
chest_ext |&gt; querygrain(nodes=disease, simplify = TRUE)
</code></pre>
<pre><code>##          yes     no
## tub   0.0104 0.9896
## lung  0.0550 0.9450
## bronc 0.4500 0.5500
</code></pre>
<pre><code class="language-r">chest_ext |&gt; querygrain(nodes=disease, evidence=list(smoke=&quot;yes&quot;), simplify = TRUE)
</code></pre>
<pre><code>##          yes     no
## tub   0.0104 0.9896
## lung  0.1000 0.9000
## bronc 0.6000 0.4000
</code></pre>
<pre><code class="language-r">chest_ext |&gt; querygrain(nodes=disease, evidence=list(smoke_guess=&quot;yes&quot;), simplify = TRUE)
</code></pre>
<pre><code>##          yes     no
## tub   0.0104 0.9896
## lung  0.0900 0.9100
## bronc 0.5667 0.4333
</code></pre>
<p>Another approach is to enter virtual evidence
in the original network as shown below.</p>
<pre><code class="language-r">chest_ve &lt;- chest_bn |&gt;
    evidence_add(evidence = list(smoke = c(.8, .1)))
chest_ve |&gt; querygrain(nodes=disease, simplify = TRUE)
</code></pre>
<pre><code>##          yes     no
## tub   0.0104 0.9896
## lung  0.0900 0.9100
## bronc 0.5667 0.4333
</code></pre>
<pre><code class="language-r">evidence_get(chest_ve)
</code></pre>
<pre><code>##   nodes is_hard hard_state evi_weight
## 1 smoke   FALSE         NA   0.8, 0.1
</code></pre>
<p>Consequently, specifying the hard evidence that
<code>smoke=&quot;yes&quot;</code> can
be done as</p>
<pre><code class="language-r">chest_bn |&gt; setEvidence(evidence=list(smoke=c(1, 0)))
</code></pre>
<pre><code>## Independence network: Compiled: TRUE Propagated: TRUE Evidence: TRUE
</code></pre>
<h2 id="building-a-network-from-data" #sec:using-data>Building a network from data</h2>
<p>When building a network from data, there are two situations to be distinguished between. 1) The network is known and the data is used to estimate the parameters in the network. 2) The network is unknown and the data is used to estimate the network structure and the parameters in the network.</p>
<p>In both cases it is possible to have a network specified as a dag or as an undirected (chordal) graph. The following code illustrates how to build a network from data. The data is simulated data from the chest clinic example.</p>
<h3 id="building-a-network-from-a-known-network" #sec:building-known>Building a network from a known network</h3>
<p>The following list defines a dag for the chest clinic example: Each component is a list with two elements: the first element is the node and the second element is a vector of parents.</p>
<pre><code class="language-r">node_parents_list &lt;- list(&quot;asia&quot;, c(&quot;tub&quot;, &quot;asia&quot;), &quot;smoke&quot;, c(&quot;lung&quot;, &quot;smoke&quot;),
              c(&quot;bronc&quot;, &quot;smoke&quot;), c(&quot;either&quot;, &quot;tub&quot;, &quot;lung&quot;),
              c(&quot;xray&quot;, &quot;either&quot;), c(&quot;dysp&quot;, &quot;bronc&quot;, &quot;either&quot;))

g1 &lt;- dag(node_parents_list)
par(mar=c(0,0,0,0))
plot(g1)
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-35" /></p>
<p>The following list defines an undirected graph for the chest clinic example: Each component is a list with the nodes in the clique.</p>
<pre><code class="language-r">cliq &lt;- list(c(&quot;xray&quot;, &quot;either&quot;), c(&quot;asia&quot;, &quot;tub&quot;), c(&quot;smoke&quot;, &quot;lung&quot;, 
&quot;bronc&quot;), c(&quot;lung&quot;, &quot;either&quot;, &quot;tub&quot;), c(&quot;lung&quot;, &quot;either&quot;, &quot;bronc&quot;
), c(&quot;bronc&quot;, &quot;either&quot;, &quot;dysp&quot;))

g2 &lt;- ug(cliq)
par(mar=c(0,0,0,0))
plot(g2)
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-36" /></p>
<p>A netowrk can be built from data using:</p>
<pre><code class="language-r">bn1 &lt;- grain(g1, data=gRbase::chestSim100000)
bn2 &lt;- grain(g2, data=gRbase::chestSim100000)
</code></pre>
<pre><code>## NAs found in clique potential(s) for clique(s): 
## c(&quot;bronc&quot;, &quot;lung&quot;, &quot;either&quot;) 
##   ... consider using the smooth argument
</code></pre>
<p>It is explained in the references that the two networks specify the same joint distribution because internally a dag is converted to an undirected chordal graph which provides the basis for the computations. In practice the two joint distributions differ slightly, and this is because the way in which information is extracted from data, see examples below.</p>
<pre><code class="language-r">j1 &lt;- querygrain(bn1, type=&quot;joint&quot;)
j2 &lt;- querygrain(bn2, type=&quot;joint&quot;)
d &lt;- j1 %a-% j2
max(abs(d))
</code></pre>
<pre><code>## [1] NaN
</code></pre>
<h2 id="building-networks-from-data" #sec:building-networks>Building networks from data</h2>
<p>The following two graphs specify the same model stating that A and C are conditionally independent given B. The first graph is a directed acyclic graph (DAG) and the second graph is an undirected graph (UG).</p>
<pre><code class="language-r">g1  &lt;- dag(~A:C + B:C, result=&quot;igraph&quot;)
g2  &lt;- ug(~A:C + B:C, result=&quot;igraph&quot;)
par(mfrow=c(1,2), mar=c(0,0,0,0))
plot(g1); plot(g2)
</code></pre>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAWgAAADYCAMAAADxhokmAAAAD1BMVEUAAAAAAIupqanmnwD////tKCWaAAAACXBIWXMAAAsSAAALEgHS3X78AAAFQUlEQVR4nO2d23KrMBAEMfj/v/kcg+04MRcJtLOz2umHPFJdXfFNCO1wFxAGb4EsKDQIhQah0CAUGoRCg1BoEAoNQqFBKDQIhQah0CAUGoRCg1BoEAoNQqFBKDQIhQah0CAUGoRCg1BoEB+hhwd+JqeI4/y2HIbpQRDthUjOL8dhuD0IYr0QyvkdenoYz9auPjWEcn4qDtNbOoL1TCznX6Fn5wDSC7GcP0Pfovx3LMRy/v3WMcWQXojlrNAgPr913IK8Cl+Ecv75Hj1Ncb79L4Ry/v5lOI6ePlX8OHubHPO91jEGKv1e6+BXXnnRhSr9gl557d1NpQ1Y/RgZZ9AqFyH3Xf+8HiOm5tbdDR0sNbXtfmiwzFWYfTt667hTl974TRWzM3PpndDE1tvQOm+tEsz/z7TWO7A6b4b++BsLUueDdS9S6104nY8WGDmt96F0PlzJpbQ+gNH5eMmc0foIQueCexOE1ofwOZfcBOKzPobOuehuG511AWzOZbc12axLIHMuvH9MZl0El3PpjXou6zKonIt3RFBZF8LkXL71hMm6FCLnij0+RNbF8DjXbKbisS6Hxrlq1xqNdQUsznXbA1msayBxrtyHSWJdBYdz7YZXDus6KJyrdxZTWFfC4Fy/hZvBuhYC5xN75Qmsq/F3PvNQgr91Pe7Op57+cLc+gbfzucdsvK3P4Ox88nkmla7l7INjKl3J6Sf0VLqO849CqnQVF545Vekarjzcq9IVXHqKWqXLufa4ukoXc/FcAJUu5eoBDCpdyOWTLlS6jOtHiqh0EQ3OblHpElockqPSBTQ5jUilj2lz7JNKH9LofC2VPqLVQWYqfUCzE+NUep92R/Op9C4Nz0BU6T1aHjap0js0PdVTpbdpe3yqSm/S+Jxald6i9YHAKr1B85OXVXqd9kdcq/QqBmeJq/QaFoe2Ry1tOuHM5MLm1gaMxhPOrC4baC7bwvCagWHkbHRVY2sDhnmey2Q24czoqsbW7RmWwTmT2eAtm4taW7dneE43ixba2Lo9Cg1Cbx0g3spWnyu2oYN9Gj4n2Npc3+aqxtYGWE84M/seHWcu2xPjCWfWvwwjrXuYTjizW0QJM5ftGwtn+5e2Ss8A3kNV+gHiw0ql75jQKn0HhVZpVGiVRoVWadgvt+ylcT+Rk5cGrkXkLo1c9EldGrq6lrk0dhkzcWnwenHe0uiF+bSl4XdAspbG32pKWtrhnl7O0h43T1OWdrlLnbG0z3aAhKWd9l3kK+21wSVdabedRNlK+23ZSlbacW9crtKemxBTlXbd7ZmptO+22kSlnfcv5yntvVE8TWnv0GlKu4fOUto/dJLSBKFzlGYInaI0RegMpTlCJyhNErr/0iyhuy9NE7r30jyhOy9NFLrv0kyhuy5NFbrn0lyhOy5NFrrf0myhuy1NF7rX0nyhOy1NGLrP0oyhuyxNGbrH0pyhn9axeu/bkoaercdYofdLs4b+bz2OPZWmDT13DhZ6rzRt6HHsqzRr6DFm6O3SpKHHqKE3S5OGjvrWcd8sTRv6ldrbop51ZeLQD/opTR66n9LsoZfS4Sac3b+c+fVH67lsFnw7B5CfnW+xSn87B3AfnhNdAs0aWXHmd1+cb6FKrzjzqz9fhOFC/3HmV1doEK9xULdYof8686u/JpxFC/3HOYD6a67qLUznNecA7oEnnMX6Hh1w9vWKcwz5aGsdD8KtdXSCQoNQaBAKDUKhQSg0CIUGodAgFBqEQoNQaBAKDUKhQSg0CIUGodAgFBqEQoNQaBAKDUKhQSg0CIUGodAg/gH5DbUpg/EbJgAAAABJRU5ErkJggg==" alt="plot of chunk unnamed-chunk-39" /></p>
<p>Given such a graph, we can build a network from data. Suppose data is as follows:</p>
<pre><code class="language-r">tab &lt;- tabNew(~A:B:C, levels=c(&quot;+&quot;, &quot;-&quot;), 
              values=c(1, 2, 3, 5, 1, 2, 1, 4))
</code></pre>
<p>A network can be built from data using:</p>
<pre><code class="language-r">bn1 &lt;- grain(g1, data=tab)
bn2 &lt;- grain(g2, data=tab)
</code></pre>
<p>The two networks specify the same joint distribution:</p>
<pre><code class="language-r">j1 &lt;- querygrain(bn1, type=&quot;joint&quot;)
j2 &lt;- querygrain(bn2, type=&quot;joint&quot;)
d &lt;- j1 %a-% j2
max(abs(d))
</code></pre>
<pre><code>## [1] 2.776e-17
</code></pre>
<p>In the process of creating networks, conditional probability tables
are extracted when the graph is a dag and clique potentials are
extracted when the graph is a chordal (i.e.\ triangulated) undirected
graph. This takes place as follows (internally):</p>
<p>Neet to estimate \(p(A|B)\), \(p(C|B)\) and \(p(B)\) from the data. This can be done as follows:</p>
<pre><code class="language-r">p &lt;- extract_cpt(tab, g1) |&gt; c()
p
</code></pre>
<pre><code>## [[1]]
## C
##      +      - 
## 0.5789 0.4211 
## 
## [[2]]
##    C
## A        +    -
##   + 0.3636 0.25
##   - 0.6364 0.75
## 
## [[3]]
##    C
## B        +     -
##   + 0.2727 0.375
##   - 0.7273 0.625
</code></pre>
<p>Likewise, we can extract the clique potentials from the data, call these \(q(AC)\) and \(q(BC)\):</p>
<pre><code class="language-r">q &lt;- extract_pot(tab, g2) |&gt; c()
q
</code></pre>
<pre><code>## [[1]]
##    C
## A        +      -
##   + 0.2105 0.1053
##   - 0.3684 0.3158
## 
## [[2]]
##    C
## B        +     -
##   + 0.2727 0.375
##   - 0.7273 0.625
</code></pre>
<p>Clique potentials are not uniquely defined, but the product of clique potentials is. In the implementation in gRain, \(q(AC)\) is the relative frequency in the \(AC\)-marginal table, i.e. \(p(AB)\). Moreover and \(q(BC)\) is the frequency in the \(BC\)-marginal table divided by the frequency in the \(C\)-marginal table. Hence, the product of the clique potentials and the product of the cpts is the same as the joint distribution:</p>
<pre><code class="language-r">tabProd(p) |&gt; ftable()
</code></pre>
<pre><code>##     C       +       -
## A B                  
## + +   0.05742 0.03947
##   -   0.15311 0.06579
## - +   0.10048 0.11842
##   -   0.26794 0.19737
</code></pre>
<pre><code class="language-r">tabProd(q) |&gt; ftable()
</code></pre>
<pre><code>##     C       +       -
## A B                  
## + +   0.05742 0.03947
##   -   0.15311 0.06579
## - +   0.10048 0.11842
##   -   0.26794 0.19737
</code></pre>
<h3 id="handling-zeros-in-the-data" #sec:handling-zeros>Handling zeros in the data</h3>
<p>Next suppose data is as follows</p>
<pre><code class="language-r">tab0 &lt;- tab
tab0[1:4] &lt;- 0
tab0
</code></pre>
<pre><code>## , , C = +
## 
##    B
## A   + -
##   + 0 0
##   - 0 0
## 
## , , C = -
## 
##    B
## A   + -
##   + 1 1
##   - 2 4
</code></pre>
<p>In the process of creating networks above, the following quantities are computed:</p>
<pre><code class="language-r">n_BC &lt;- tab0 |&gt; tabMarg(~B:C)
n_AC &lt;- tab0 |&gt; tabMarg(~A:C)
n_C  &lt;- tab0 |&gt; tabMarg(~C)

p.B_C &lt;- n_BC %a/% n_C
p.A_C &lt;- n_AC %a/% n_C
p.C &lt;- n_C / sum(n_C)
p.C
</code></pre>
<pre><code>## C
## + - 
## 0 1
</code></pre>
<pre><code class="language-r">p.B_C
</code></pre>
<pre><code>##    C
## B     +     -
##   + NaN 0.375
##   - NaN 0.625
</code></pre>
<pre><code class="language-r">p.A_C
</code></pre>
<pre><code>##    C
## A     +    -
##   + NaN 0.25
##   - NaN 0.75
</code></pre>
<pre><code class="language-r">bn01 &lt;- grain(g1, data=tab0)
</code></pre>
<pre><code>## NAs found in cpt(s) for node(s): A, B
##   ... consider using the smooth argument
</code></pre>
<pre><code class="language-r">bn02 &lt;- grain(g2, data=tab0)
</code></pre>
<pre><code>## NAs found in clique potential(s) for clique(s): 
## c(&quot;B&quot;, &quot;C&quot;) 
##   ... consider using the smooth argument
</code></pre>
<pre><code class="language-r">p &lt;- extract_cpt(tab0, g1) |&gt; c()
</code></pre>
<pre><code>## NAs found in cpt(s) for node(s): A, B
##   ... consider using the smooth argument
</code></pre>
<pre><code class="language-r">q &lt;- extract_pot(tab0, g2) |&gt; c()
</code></pre>
<pre><code>## NAs found in clique potential(s) for clique(s): 
## c(&quot;B&quot;, &quot;C&quot;) 
##   ... consider using the smooth argument
</code></pre>
<pre><code class="language-r">p
</code></pre>
<pre><code>## [[1]]
## C
## + - 
## 0 1 
## 
## [[2]]
##    C
## A     +    -
##   + NaN 0.25
##   - NaN 0.75
## 
## [[3]]
##    C
## B     +     -
##   + NaN 0.375
##   - NaN 0.625
</code></pre>
<pre><code class="language-r">q
</code></pre>
<pre><code>## [[1]]
##    C
## A   +    -
##   + 0 0.25
##   - 0 0.75
## 
## [[2]]
##    C
## B     +     -
##   + NaN 0.375
##   - NaN 0.625
</code></pre>
<pre><code class="language-r">tabProd(p) |&gt; ftable()
</code></pre>
<pre><code>##     C       +       -
## A B                  
## + +       NaN 0.09375
##   -       NaN 0.15625
## - +       NaN 0.28125
##   -       NaN 0.46875
</code></pre>
<pre><code class="language-r">tabProd(q) |&gt; ftable()
</code></pre>
<pre><code>##     C       +       -
## A B                  
## + +       NaN 0.09375
##   -       NaN 0.15625
## - +       NaN 0.28125
##   -       NaN 0.46875
</code></pre>
<pre><code class="language-r">eps &lt;- 0.01
bn01e &lt;- grain(g1, data=tab0, smooth=eps)
bn02e &lt;- grain(g2, data=tab0, smooth=eps)
</code></pre>
<pre><code class="language-r">j1 &lt;- querygrain(bn01e, type=&quot;joint&quot;)
j2 &lt;- querygrain(bn02e, type=&quot;joint&quot;)
j1
</code></pre>
<pre><code>## , , B = +
## 
##    A
## C           +         -
##   + 0.0006219 0.0006219
##   - 0.0941379 0.2805496
## 
## , , B = -
## 
##    A
## C           +         -
##   + 0.0006219 0.0006219
##   - 0.1564809 0.4663440
</code></pre>
<pre><code class="language-r">j2
</code></pre>
<pre><code>## , , B = +
## 
##    C
## A           +       -
##   + 0.0006219 0.09383
##   - 0.0006219 0.28055
## 
## , , B = -
## 
##    C
## A           +      -
##   + 0.0006219 0.1562
##   - 0.0006219 0.4670
</code></pre>
<pre><code class="language-r">d &lt;- j1 %a-% j2
max(abs(d))
</code></pre>
<pre><code>## [1] 0.0006182
</code></pre>
<h3 id="building-a-network-from-an-unknown-network" #sec:building-unknown>Building a network from an unknown network</h3>
<p>This is a more complex task, sometimes called structural learning. The
following code illustrates how to build a network from data. The data
is simulated data from the chest clinic example.</p>
<p>We illustrate two approaches: 1) based on the stepwise algorithm in
the gRim package and 2) based on the hill climbing algorithm in the
bnlearn package.</p>
<pre><code class="language-r">dat &lt;- gRbase::chestSim10000

## Using gRim and stepwise selection
sat_model &lt;-  gRim::dmod(~.^., data=dat)
mm1 &lt;- stepwise(sat_model, criterion=&quot;aic&quot;, type=&quot;decomposable&quot;)
##bn1 &lt;- grain(mm1$modelinfo$ug, data=dat)
bn1 &lt;- grain(mm1$modelinfo$ug, data=dat, smooth=0.01)

## Using bnlearn and hill climbing
sat_graph &lt;- bnlearn::random.graph(names(dat), prob = 1) # complete graph
mm2 &lt;- bnlearn::hc(dat, start=sat_graph)
bn2 &lt;- bnlearn::as.grain(bnlearn::bn.fit(mm2, dat))
bn2$dag
</code></pre>
<pre><code>## IGRAPH a74c9a2 DN-- 8 9 -- 
## + attr: name (v/c)
## + edges from a74c9a2 (vertex names):
## [1] smoke-&gt;lung   smoke-&gt;bronc  tub  -&gt;either lung -&gt;either tub  -&gt;xray  
## [6] lung -&gt;xray   tub  -&gt;dysp   lung -&gt;dysp   bronc-&gt;dysp
</code></pre>
<p>An important detail is that gRim works with decomposable undirected
graphical models (see Figure @ref(fig:bn1)) while bnlearn works with
dags (see Figure @ref(fig:bn2), left). However, even for models
specified as dags, all comptational structures are based on a
corresponding undirected graph (see Figure @ref(fig:bn2), left). For
details, see the references.</p>
<p><img src="data:image/png;base64,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" alt="XXXX." /></p>
<p><img src="data:image/png;base64,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" alt="XXXX." /></p>
<h2 id="extending-networks-to-include-other-types-of-variables" #sec:mixture>Extending networks to include other types of variables</h2>
<p>gRain only handles discrete variables with a finite state space, but
using likelihood evidence it is possible to work with networks with
both discrete and continuous variables (or other types of variables).
This is possible only when he networks have a specific structure. This
is possible when no discrete variable has non–discrete parents.</p>
<p>Take a simple example: Form a network for variables \(x=(x_1, x_2)\).
Conceptually augment this network with additional variables \(y=(y_1, y_2)\) where
\(y_1|x_1=k \sim N(\mu_k, v)\) and
\(y_2|x_2=k \sim Poi(l_k)\) for \(k=1,2\). Also we make the assumption
that \(y_1\) and \(y_2\) are independent given \(x=(x_1, x_2)\). This gives the DAG
below:</p>
<pre><code class="language-r">par(mar=c(0,0,0,0))
plot(dag(~y1:x1 + x2:x1 + y2:x2))
</code></pre>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAWgAAADYCAMAAADxhokmAAAAD1BMVEUAAAAAAIupqanmnwD////tKCWaAAAACXBIWXMAAAsSAAALEgHS3X78AAAEdklEQVR4nO3dy3LbMBBEUQL0/39zQll8qJzKxpiZ7um+C2dngacYmSLh8fblUtqqF6CSoZMydFKGTsrQSRk6qRDo7SjiGxMX4LFt+5GpP1qv8c2872O39KPlGJfz2C39aD30OE7m1xlt6EerLbb9AW3pu/XQf4UN/bMI6LEb+keGTioA+v3OYeiPAi7vxn5m5ztDJ7XcYtj5n4Xe65hz/XdnLfTu3bT0Vex/b0tfBb+PTlO/i/6BZel3GdC2/kp4Zjivol8Ju/hrXTu/SoMOfx3wsqDDXwa9hI/Jhj7Kgf77Jf51sEuBfn2NfyHoMqA//lEt8VamtnTmPWNp6dSb88rSuU9BhKWTHzfpSmc/15OVTn+Aqiqd/6RaVLpgS4CmdMXeC0npkk0uitI1u4kEpYu2belJV+2Pk5Mu24ioJl2341NMunBrrZZ05R5mKenSzeJK0rW78oWki3/9QUe6+vdMZKSroWWky6FVpOuhRaQBoDWkEaAlpCGgFaQxoAWkQaD7S6NAt5eGge4ujQPdXBoI+lu661xTqGOajeeaYh3R1nd6DdQBXc4Nx21CHU/nAbJIx7Od0zY7DidEOpzWUyCRDmfbz5l5hg7NZ3RSfo/OaryNfdUR3P15xdCx+ZNhVo+5ptVLWRwY9OPuXTNpOOi7XtLA0L2kkaFbSUNDd5LGhm4kDQ7dRxoduo00PHQXaXzoJtIE0D2kGaBbSFNAd5DmgG4gTQLNL80CTS9NA80uzQNNLk0EzS3NBE0tTQXNLM0FTSxNBs0rzQZNK00HzSrNB00qTQjNKc0ITSlNCc0ozQlNKE0KzSfNCk0nTQvNJs0LTSZNDM0lzQxNJU0NzSTNDU0kTQ7NI80OTSNND80izQ9N8gfeG0B/E09DxzcPZ0MnNKehU5r40i2gp6FTmoZOaU4G6QbQR/jSTaC/vq2r1/Cf+kCDSzeCxv7U0gr6LQ05vR5uQb9rwk6vB1vO70OdUYi1mt+3nTPV0cabQi1mQfcJPQwd2D0ZGe0PMiCtZUH3rG9Dh4Y7vR5pLQu6zuiBdt2BtJYFne/RA+6nIdJaVvRWHsf1HdSxQS1mQbDT66EWsyJ/MswKdHp9P2jQ6fUdoe+ApHtDA0k3h8aR7g4NI90eGkW6PzSItAA0hrQCNIS0BDSCtAY0gLQIdL20CnS5tAx0tbQOdLG0EHSttBJ0qbQUdKW0FnShtBh0nbQadJm0HHSVtB50kbQgdI20InSJtCR0hbQmdIG0KHS+tCp0urQsdLa0LnSytDB0rrQydKq0NHSmtDZ04lxTcei8uabq0GlzTeWhs+aaGjppYp48dNZoQnXotGmb4tB5c03FoY9ypA19ZOis4qUN/S5a2tBnwXNNDX11zjUdYwSoGPrRNb0mQNrQd9s4p+YFDL4y9J2hc3pNgbymE66GMfRV7BRIQ1+d0DFTIA19tZ3IIVO+DX11T+r1W0ds2wPaVx2BjcAT2tDPIueaGvpZ4N9wMfRnvnvHnqGTMnRShk7K0EkZOilDJ/UHDWy3ZwTVNr0AAAAASUVORK5CYII=" alt="plot of chunk unnamed-chunk-53" /></p>
<p>A network for \(x\) can be constructed as:</p>
<pre><code class="language-r">u &lt;- list(x1=yn, x2=yn)
x1 &lt;- cpt(~x1, values=c(1, 3), levels=u)
x2 &lt;- cpt(~x2|x1, values=c(3, 1, 1, 7), levels=u)
bn &lt;- grain(compile_cpt(x1, x2))
querygrain(bn, simplify=TRUE)
</code></pre>
<pre><code>##       yes     no
## x1 0.2500 0.7500
## x2 0.2812 0.7188
</code></pre>
<p>The augmentation of \(y|x\) can go along these lines: The parameters
describing \(y|x\) are set to be:</p>
<pre><code class="language-r">s &lt;- 2
mu &lt;- c(mu1=2, mu2=5)
lambda &lt;- c(lambda1=1, lambda2=5)
</code></pre>
<p>Suppose we observe \(y_1 = y_1^*\). Then</p>
<p>\begin{align} p(x|y_1= y_1^*)\propto p(x_1)p(x_2|x_1) p(y_1=y_1^*|x_1) =  p(x_1)p(x_2|x_1) L_1(x_1) \end{align}</p>
<p>where \(L_1(x_1)\) denotes the likelihood. In a network setting this
corresponds to changing \(p(x_1)\) as
\begin{align} p(x_1) \leftarrow p(x_1)L_1(x_1) \end{align}
and then carry on with propagation. This can be achieved in different ways.</p>
<p>The likelihood is:</p>
<pre><code class="language-r">y1_obs &lt;- 14 # Observed value for y1_obs
lik1 &lt;- dnorm(y1_obs, mean=mu, sd=s)
lik1
</code></pre>
<pre><code>##       mu1       mu2 
## 3.038e-09 7.992e-06
</code></pre>
<p>One is by setting the likelihood as evidence.
An alternative is to explicitly modify the CPT which specifies \(p(x_1)\):</p>
<pre><code class="language-r">querygrain(bn, simplify=TRUE, exclude=FALSE)
</code></pre>
<pre><code>##       yes     no
## x1 0.2500 0.7500
## x2 0.2812 0.7188
</code></pre>
<pre><code class="language-r">bn1 &lt;- setEvidence(bn, evidence=list(x1=lik1))
querygrain(bn1, simplify=TRUE, exclude=FALSE)
</code></pre>
<pre><code>##          yes     no
## x1 0.0001267 0.9999
## x2 0.1250792 0.8749
</code></pre>
<pre><code class="language-r">x1_upd &lt;- getgrain(bn, &quot;cptlist&quot;)$x1 * lik1
bn2 &lt;- replace_cpt(bn, list(x1=x1_upd))
querygrain(bn2, simplify=TRUE) 
</code></pre>
<pre><code>##          yes     no
## x1 0.0001267 0.9999
## x2 0.1250792 0.8749
</code></pre>
<p>A final remark: The conditional distribution of
\(y_1\) is normal, but the unconditional distribution is a mixture of
normals. Likewise, the conditional distribution of
\(y_2\) is poisson, but the unconditional distribution is a mixture of
two poisson distributions. Evidence on, say \(y_1\) changes the belief in \(x_1\) and
\(x_2\) and this in turn changes the distribution of
\(y_2\) (evidence changes the mixture weights.)</p>
<pre><code class="language-r">nsim &lt;- 10000
xsim_marg &lt;- simulate(bn, nsim, seed=2022)
xsim_cond &lt;- simulate(bn1, nsim, seed=2022)
y2marg  &lt;- rpois(n=nsim, lambda=lambda[xsim_marg$x2])
y2cond  &lt;- rpois(n=nsim, lambda=lambda[xsim_cond$x2])
summary(y2marg)
</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    0.00    2.00    4.00    3.88    6.00   16.00
</code></pre>
<pre><code class="language-r">summary(y2cond)
</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    0.00    3.00    4.00    4.52    6.00   15.00
</code></pre>
<pre><code class="language-r">par(mfrow=c(1,2))
y2marg |&gt; hist(prob=T, ylim=c(0, .4), breaks=20, main=&quot;marginal p(y2)&quot;)
y2cond |&gt; hist(prob=T, ylim=c(0, .4), breaks=20, main=&quot;conditional p(y2|y1*)&quot;)
</code></pre>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAWgAAADYCAMAAADxhokmAAAACVBMVEUAAADT09P////tw7KtAAAACXBIWXMAAAsSAAALEgHS3X78AAAHBUlEQVR4nO2djXbyKhBFp3n/h77fMgmQxBkIP4fBe/ZqaxUJJ1sCRG2VjUCQ2QH+L1A0CIoGQdEgKBoERYOgaBAUDYKiQVA0CIoGQdEgKBoERYOgaBAUDYKiQVA0CIoGQdEgKBoERYOgaBCDRd83L8o1Efn3PTbLN2T/ElWEFTgtlP2Hvg8+RIt8TI/N8o1a0ffA+xasfeixc3sLn7aOB3oPf+zFtShU2O8SS8Z2aTlalC0kChGDtEtxSeAtJD+K9X3oIvogPND7t5zdJS2KFfa2QaJDMLknSnr0t2I7cKi9YUTHqPFRT29Lio7c4UrIZhy+3SLGKI9g2u1m4LvobdP3oafo88FOGo+5t7SDnFfjvoS0Q5CkjdNXGlHiDfIicPJYhOgY0XJOCE/RoehrbjF7Q3vCCtEFgaeJvh5hF9FJUXrTdk483cJYEd8MHSWB5bw6QXQygV/iJ0VpYaw5eIy+TIZn5mS+vt5QGDgei/ihI4SLc0W6W2eqOCRjRG/X5d3ZGbeL6GtxQWC0aA1120eBJEG366/OUAJv2auPTXTn6KNmo0ffGJ6lHSXw9ria7VzdsTyHRuXaA9yLvgfenj0YLprcoGgQFA2CokFQNAiKBkHRICgaBEWDoGgQFA2CokFQNAiKBkHRICgaBEWDoGgQhaJXfDx8Zc6mkRNEmk54zFyQJbyjYSH8ZS5JE95HshDuMpelcXUQFuIss680P0yx6BUfEU+Za7J4nNRzTM/c0vBKok8ci9Z7gl/RDjPnT1j0O7oV7TEzRYMoOAVPL97VnYXHzCWn4Npk7Va0x8xcdSzQMEWDGqZoUMMUDWqYokENUzSoYYoGNUzRoIYpGtQwRYMapmhQwxQ9uOHpLwtVMD0zezS04brm54peLPPRcNVBNblHr5U5afh1cAdDxzqZw8tr8R83va47i6Uy66+uldadxWKZ5fHzbd1ZLJb5c+xVrjFnil4uM5d3IPbZZLHesS2YmWeG8Ibfz+LzRS+UOSzvRAuhr1blnJMG5tOpzjyHMBlqoSX5fhbJ3z8mia7NPIdTtPpfheX44VB0ZeY5SLzQjsK93J3o6sxzKGh4T+1PtIWVeQ7J06Q1a9KpPXrBdXRpvz5+jae/cyfDF3dx8lJW9emsb9HdanXgXEevN3T83Cm4+adkTifD3/vzN5+i7cxziKsObU16u7wWTV51VGWeQ/4UXNKLe12np+Bm5jlkRW/mn5L5FG1nnkN47Cs+t3H2qqMys7a5scvsMJzVvRll6mTY6w00u+K/sbuSTIY1dWdPhu8rfbvtsxMI0d8+bKus7jzR9Zmft6FEG6uhXN1pohsyP29bVTTi2Zv/u+g4rywhWpK8CNH17/p5iA6ZR4tuyBwrHnYT0cOOxpZtXkTfO4e7J0B2JNj9XHuIHtavu4hO1qEUrTfcUle+BaXo7w231DVET33hSGUp0Y/XDL+K9tWt75mXEJ3UXUb0SRT9bWKh6G6I1o0vogcMexT9TfSA7BT9G6LdrT1+VfSft35N0SBeiO57NFK0Krpvdor+JdGOZsTfFu2oWzsWXfAmR3ei85mLRfc6GrPbMF4zciu6IHOx6F7ZcaKBA/WaoiW9+Bq6TDSwWxdk9id6K3iTY7loVLfOZn4nukNu3KoD3a3tzO9E/7XnLq7dZ+jo1T+aM9eIbsrd+lLWCCp3xXdmJ+cRv0/LCYtfHGZuWUdv/Q/DvjuFyVwWvFV0xYaNJjGiC2r2LCu8h7H4N6tPFV2ZeapoY/FvVp8pujbzZNF11eeKtqBoiq6pTtFv71FZnaLf3oN0gaJBUDQIigZB0SAoGgRFg6BoEBQNokm08QyZViR6NbHqdcNqIPOUX2af7OBtotX66mZFryatcYrQM2efHNCqFgVv2TOjAe3m839rP8vl/ccx1WA2ohfouUuDjxKtHUh6YPPo7IYtWm/dyF0WfFyPVsczU/ToTp3r0cYYbYvOBR8kWi3JiG5MlCd3mNeKzmyWopUQ326fJ9oYIKyhw1h16PW6YQ0P9tBhrTrywdtEW+tovT17Hd0SqIDMOlotMoqHT4bkBRQNgqJBUDQIigZB0SAoGgRFg6BoEBQNgqJBUDQIigZB0SAoGgRFg6BoEBQNgqJBUDSIwS/u+/pXDkXU/W1zfrMtlUu2vpxpPbNL0ftL8Nvxpof9ozTl/Gi88W/OreKeOQQ+fnoVLckvny+5XPPHI/MtsEvR2/FR0nKNeeZ3KTrJfIZNnbsWHe1u54jhXnSaexXRlyMx5PYtOjpeRHQc1KLo20DijXvmJcboY+pO1UqI7nPVccmcrDq6ZB4qekq7LQxMNUW016FjSdHWhh2PHEtumyRQNAiKBkHRICgaBEWDoGgQFA2CokFQNAiKBkHRICgaBEWDoGgQFA3iP/3tQ1m7pCA/AAAAAElFTkSuQmCC" alt="plot of chunk unnamed-chunk-58" /></p>
<h2 id="brute-force-computations-and-why-they-fail" #sec:brute-force-comp>Brute force computations and why they fail</h2>
<p>The gRain package makes computations as those outlined above in a very
efficient way; please see the references.  However, it is in this
small example also possible to make the computations directly: We can
construct the joint distribution (an array with \(2^8=256\) entries)
directly as:</p>
<pre><code class="language-r">joint &lt;- tabProd(chest_cpt)
dim(joint)
</code></pre>
<pre><code>## [1] 2 2 2 2 2 2 2 2
</code></pre>
<pre><code class="language-r">joint  |&gt; as.data.frame.table() |&gt; head()
</code></pre>
<pre><code>##   xray smoke asia tub lung dysp bronc either      Freq
## 1  yes   yes  yes yes  yes  yes   yes    yes 1.323e-05
## 2   no   yes  yes yes  yes  yes   yes    yes 2.700e-07
## 3  yes    no  yes yes  yes  yes   yes    yes 6.615e-07
## 4   no    no  yes yes  yes  yes   yes    yes 1.350e-08
## 5  yes   yes   no yes  yes  yes   yes    yes 2.620e-04
## 6   no   yes   no yes  yes  yes   yes    yes 5.346e-06
</code></pre>
<p>This will clearly fail even moderate size problems: For example, a
model with \(80\) nodes each with \(10\) levels will give a joint state
space with \(10^{80}\) states; that is about the number of atoms in the
universe. Similarly, \(265\) binary variables will result in a joint
state space of about the same size. Yet, gRain has been used
successfully in models with tens of thousand variables.  The ``trick’’
in gRain is to make all computations without ever forming the joint
distribution.</p>
<p>However, we
can do all the computations by brute force methods as we will
illustrate here:</p>
<p>Marginal distributions are</p>
<pre><code class="language-r">tabMarg(joint, &quot;lung&quot;)
</code></pre>
<pre><code>## lung
##   yes    no 
## 0.055 0.945
</code></pre>
<pre><code class="language-r">tabMarg(joint, &quot;bronc&quot;)
</code></pre>
<pre><code>## bronc
##  yes   no 
## 0.45 0.55
</code></pre>
<p>Conditioning on evidence can be done in different ways: The
conditional density is a \(6\)–way slice of the original \(8\)–way joint
distribution:</p>
<pre><code class="language-r">asia_dysp
</code></pre>
<pre><code>## $asia
## [1] &quot;yes&quot;
## 
## $dysp
## [1] &quot;yes&quot;
</code></pre>
<pre><code class="language-r">cond1 &lt;- tabSlice(joint, slice=asia_dysp)
cond1 &lt;- cond1 / sum(cond1)
dim(cond1)
</code></pre>
<pre><code>## [1] 2 2 2 2 2 2
</code></pre>
<pre><code class="language-r">tabMarg(cond1, &quot;lung&quot;)
</code></pre>
<pre><code>## lung
##     yes      no 
## 0.09953 0.90047
</code></pre>
<pre><code class="language-r">tabMarg(cond1, &quot;bronc&quot;)
</code></pre>
<pre><code>## bronc
##    yes     no 
## 0.8114 0.1886
</code></pre>
<p>Alternatively, multiply all entries not consistent by zero and all
other entries by one and then marginalize:</p>
<pre><code class="language-r">cond2 &lt;- tabSliceMult(joint, slice=asia_dysp)
cond2 &lt;- cond2 / sum(cond2)
dim(cond2)
</code></pre>
<pre><code>## [1] 2 2 2 2 2 2 2 2
</code></pre>
<pre><code class="language-r">tabMarg(cond2, &quot;lung&quot;)
</code></pre>
<pre><code>## lung
##     yes      no 
## 0.09953 0.90047
</code></pre>
<pre><code class="language-r">tabMarg(cond2, &quot;bronc&quot;)
</code></pre>
<pre><code>## bronc
##    yes     no 
## 0.8114 0.1886
</code></pre>
</div>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/combine/npm/katex/dist/katex.min.js,npm/katex/dist/contrib/auto-render.min.js,npm/@xiee/utils/js/render-katex.js" defer></script>
</body>
</html>
